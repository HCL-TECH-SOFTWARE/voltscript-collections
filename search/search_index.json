{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome","text":"<ul> <li> <p> What's New?</p> <p>Find out what's new in the latest VoltScript Collections release.</p> <p> Go to What's New</p> </li> <li> <p> Tutorials</p> <p>Hands-on introduction to VoltScript Collections.</p> <p> Go to Tutorials</p> </li> <li> <p> How-to guides</p> <p>Practical step-by-step guides for performing tasks and operation.</p> <p> Go to How-to guides</p> </li> <li> <p> Topic guides</p> <p>High-level discussion and explanation of key topics and concepts to give background information.</p> <p> Go to Topic guides</p> </li> <li> <p> References</p> <p>Technical references and descriptions on using VoltScript Collections.</p> <p> Go to References</p> </li> <li> <p> Using via dependency management</p> <p>For using with dependency management, see Use dependency management.</p> </li> <li> <p> Quick links</p> <p>Why VoltScript Collections and Maps?</p> </li> </ul>"},{"location":"whatsnew.html","title":"What's new","text":"<p>The section provides information on the latest features, improvements, and resolved issues related to VoltScript Collections.</p> <p>Important</p> <p> Items marked in red are API changes that may impact your applications and should be reviewed before upgrading.</p> v1.0.6 - What's new or changed v1.0.5 - What's new or changed v1.0.4 - What's new or changed v1.0.3 - What's new or changed v1.0.2 - What's new or changed v1.0.1 - What's new or changed v1.0.0 - What's new or changed"},{"location":"whatsnew.html#v106","title":"v1.0.6","text":"<p>Improvements</p> <ul> <li>Support for negative numbers in getNth... APIs. This will get the nth element working from the end.</li> </ul>"},{"location":"whatsnew.html#v105","title":"v1.0.5","text":"<p>Improvements</p> <ul> <li>Integrating VoltScript Logging for error handling</li> <li>Repointing atlas.json from demo marketplace. atlas-settings marketplace url will need updating to \"https://accounts.auth.hclvoltmx.net/login\"</li> </ul>"},{"location":"whatsnew.html#v104","title":"v1.0.4","text":"<p>Improvements</p> <ul> <li>Repointing atlas.json to use VSE title and filename as library and module.</li> </ul>"},{"location":"whatsnew.html#v103","title":"v1.0.3","text":"<p>Improvements</p> <ul> <li>Added VSID database to repo</li> <li>Repointing atlas.json from demo marketplace. atlas-settings marketplace url will need updating to \"https://accounts.auth.hclvoltmx.net/login\"</li> </ul>"},{"location":"whatsnew.html#v102","title":"v1.0.2","text":"<p>Resolved Issues</p> <ul> <li>Adding to a sorted Collection returned the total elements in the Collection, not the index at which the element was added.</li> <li>Converting an empty Collection to JSON returned a JSON object, not a JSON array.</li> </ul>"},{"location":"whatsnew.html#v101","title":"v1.0.1","text":"<p>Improvements</p> <ul> <li>Updated API doc from VoltScript Interface Designer.</li> <li>Code merged with skeletons auto-generated from VoltScript Interface Designer.</li> </ul> <p>Resolved Issues</p> <ul> <li>There was an incorrect return type from putPair.</li> </ul>"},{"location":"whatsnew.html#v100","title":"v1.0.0","text":"<ul> <li>First release version of VoltScript Collections.</li> </ul>"},{"location":"howto/index.html","title":"How-to guides","text":"<p>How-to guides instruct users in completing key goals and tasks related to VoltScript Collections.</p> <ul> <li>Create a Collection / Map</li> <li>Interrogate the Collection</li> <li>Iterate a Collection</li> <li>Simulate a stack / queue</li> <li>Create your own comparator</li> <li>Extend Collection / Maps</li> <li>Filter Collection / Maps</li> <li>Transform Collections / Maps</li> <li>Use dependency management</li> <li>Error Handling</li> </ul>"},{"location":"howto/archipelago.html","title":"Use dependency management","text":"<p>Info</p> <p>For generic how-to information about VoltScript Dependency Management, see VoltScript documentation.</p> <p>Dependency management is available in the documentation for each project, but also aggregated here:</p>"},{"location":"howto/archipelago.html#authentication","title":"Authentication","text":"<p>You'll need a Personal Access Token to use GitHub REST APIs. You'll then need to add the following to the JSON object in your atlas-settings.json in the <code>.vss</code> directory of your user home directory:</p> <pre><code>    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    },\n    \"volt-mx-marketplace\": {\n        \"type\": \"marketplace\",\n        \"username\": \"YOUR_USERNAME\",\n        \"password\": \"YOUR_PASSWORD\",\n        \"authUrl\": \"https://accounts.auth.demo-hclvoltmx.net/login\"\n    }\n</code></pre>"},{"location":"howto/archipelago.html#repository","title":"Repository","text":"<p>You'll need to add the following to your repositories object in the <code>atlas.json</code> of your project:</p> <pre><code>    {\n        \"id\": \"volt-mx-marketplace\",\n        \"type\": \"marketplace\",\n        \"url\": \"https://community.demo-hclvoltmx.com/marketplace\"\n    },\n    {\n        \"id\": \"hcl-github\",\n        \"type\": \"github\",\n        \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n    }\n</code></pre>"},{"location":"howto/archipelago.html#dependency","title":"Dependency","text":"<p>You'll need to add the following relevant dependency to your dependencies or testDependencies object in the <code>atlas.json</code> of your project:</p> <pre><code>    {\n        \"library\": \"voltscript-collections\",\n        \"version\": \"1.0.5\",\n        \"module\": \"VoltScriptCollections.vss\",\n        \"repository\": \"hcl-github\"\n    }\n</code></pre>"},{"location":"howto/comparator.html","title":"Create your own comparator","text":"<p>Because sort order is stored in a separate property, creating a custom comparator is straightforward, regardless of whether you want to sort ascending or descending.</p>"},{"location":"howto/comparator.html#1-constructor","title":"1. Constructor","text":"<p>The first step is to create the constructor. A constructor is required because the constructor of the base class <code>Comparator</code> takes an argument. However, unless you are running additional code, you don't need to add anything to the body of the comparator.</p>"},{"location":"howto/comparator.html#2-compare-function","title":"2. compare() Function","text":"<p>The <code>compare()</code> function just needs to be coded for ascending comparison, that is A-Z, 0 to 9. The base class's <code>compareAscDesc()</code> function handles flipping the result if the comparator should be sorted descending or the collection is reversed.</p> <p>There are private <code>compareDataType()</code> and <code>compareMatchingDataType()</code> functions in the base class which can be called to avoid having to manually code comparisons, and these takes the same arguments as the <code>compare()</code> function.</p> <p>Note</p> <p>For more details on how these handle different data types, see Base Comparator and MatchingDataType Comparator.</p> <p>These functions return an integer, as should your <code>compare()</code> function:</p> <ul> <li>-1 is used for \"before\".</li> <li>0 is used for \"matches\".</li> <li>1 is used for \"after\".</li> </ul>"},{"location":"howto/comparator.html#3-equals-function","title":"3. equals() Function","text":"<p>The <code>equals()</code> function just returns a boolean, <code>true</code> if source and target should be considered the same, <code>false</code> if they should not.</p> <p>Note</p> <p>For more details on why two functions are required, see Sorting and Comparators.</p>"},{"location":"howto/comparator.html#sample-comparator","title":"Sample comparator","text":"<pre><code>Class PersonSorter as Comparator\n\n    Sub New(isDescending as Boolean)\n        'Nothing needed here\n    End Sub\n\n    Function compare(source as Variant, target as Variant) as Integer\n        compare = Me.compareMatchingDataType(CStr(source.FirstName) &amp; \"~\" &amp; CStr(source.LastName), CStr(target.firstName) &amp; \"~\" &amp; CStr(target.LastName))\n        If (compare &lt;&gt; 0) Then Return compare\n\n        compare = Me.compareMatchingDataType(source.Age, target.Age) * -1\n    End Function\n\n    Function equals(source as Variant, target as Variant) as Boolean\n        Return CStr(source.firstName) = CStr(target.firstName) &amp;&amp;_\n            CStr(source.lastName) = CStr(target.lastName) &amp;&amp;_\n            CStr(source.age) = CStr(target.age) &amp;&amp;_\n            CStr(source.value1) = CStr(target.value1) &amp;&amp;_\n            CStr(source.value2) = CStr(target.value2)  ' (1)!\n    End Function\n\nEnd Class\n</code></pre> <ol> <li>Alternatively, your class could have an <code>equals()</code> function, accepting an instance of the same class and returning a Boolean if it matches.</li> </ol> <p>What does the code mean?</p> <p>Lines 3 to 5 are the constructor. This is forced by the compiler because the base class's constructor takes arguments.</p> <p>Line 7 starts the <code>compare()</code> function. This will sort on name, then on age eldest to youngest.</p> <p>Line 8 uses the private function <code>compareMatchingDataType()</code> to compare the names in format FIRSTNAME~LASTNAME. The <code>firstName</code> and <code>lastName</code> properties are strings, but <code>source</code> and <code>target</code> are Variants. So the compiler cannot know that they are strings. We could cast <code>source</code> and <code>target</code> to the <code>Person</code> class. But for brevity of code, and because we know it cannot throw an error, we just <code>CStr()</code> the property values. If the names could include diacritics, we would need to use <code>StrCompare()</code> instead.</p> <p>On line 9, if the comparison returned -1 or 1, we just return that value. If the names are the same, we need to check age.</p> <p>Line 11 uses <code>compareMatchingDataType()</code> to compare on age, then multiplies the result by -1. If the ages match, the result (0) will still be 0. If the source age is younger, the result (-1) will be changed to 1. If the source age is older, the result (1) will be changed to -1. This will result in the following order by default:</p> <ol> <li>Jane Doe, 32</li> <li>Jane Doe, 30</li> <li>John Doe, 42</li> <li>Steve Smith, 60</li> </ol> <p>By default, the comparator will sort A-Z on first name, A-Z on last name, then eldest to youngest on age. If <code>true</code> is passed to the constructor (descending) or the collection is reversed, it will be Z-A on first name, Z-A on last name, then youngest to eldest on age.</p>"},{"location":"howto/create.html","title":"Create a Collection / Map","text":"<p>To create a collection, you need to pass four arguments:</p> <ul> <li>The type(s) the collection contains, as a string.</li> <li>A Comparator to use for ordering and matching elements.</li> <li>A boolean for whether the collection's elements must be unique.</li> <li>A boolean for whether the collection's elements should be sorted.</li> </ul> <p>Maps always have unique keys, so their constructors only take three arguments:</p> <ul> <li>The type(s) the collection contains, as a string.</li> <li>A Comparator to use for ordering and matching keys.</li> <li>A boolean for whether the collection's elements should be sorted.</li> </ul> <p>For maps, the comparator is used to sort the keys, not the values. When the comparator is called, it will not have access to the value, only the scalar key for the key/value pair.</p> <p>Map keys can be any scalar value, but cannot be objects. If combining properties of an object to make a unique key, it's recommended to use a delimiter that will not be used for either property. If including numerics in the unique key, it's recommended to format to a maximum number of digits, e.g. for an age <code>Format(obj.age, \"000\")</code>.</p>"},{"location":"howto/create.html#defining-content-types","title":"Defining Content Type(s)","text":"<p>The content type is a string. You cannot use \"NULL\", \"EMPTY\", \"VARIANT\", \"NOTHING\", \"ARRAY\" or \"LIST\". It is checked in <code>continueAdd()</code> function and will be compared to the result of <code>TypeName(value)</code>, where value is the variable being added to the collection or map. Additional details can be found in Valid Content Types.</p> <p><code>TypeName()</code> only returns the specific class used, there is no way to identify all parent classes of a derived class. As a result, you must include all explicit class names in the instantiation.</p>"},{"location":"howto/create.html#example","title":"Example","text":"<p>Imaging you have an <code>Animal</code> class and a <code>Pet</code> class that extends the Animal class. But you want to create a collection that can contain both. This is achieved by declaring the collection like so:</p> <pre><code>Dim coll as New Collection(\"ANIMAL,PET\", animalComparator, False, True) ' (1)\n</code></pre> <ol> <li>Assumes a variable called <code>animalComparator</code> that uses a class extending Comparator, to sort animals and pets.</li> </ol>"},{"location":"howto/create.html#populating-a-collection-or-map","title":"Populating a Collection or Map","text":"<p>Individual elements can be added to a collection using <code>add()</code>. This will add the element at the end of the collection, if it is unsorted, or in its relevant position, if sorted.</p> <p>For unsorted collections, <code>insertAt()</code> can be used to place the element at a particular index. This will not replace the element at that index, all subsequent elements will be shuffled one place down the collection. To find and replace an existing element, use <code>replace()</code>. To replace an element at a specific position, use <code>remove()</code> and <code>insertAt()</code>.</p> <p>To add multiple elements, use <code>addAll()</code>. This can take either another Collection object or an array of objects / scalars. If the collection or array includes elements that are invalid, an error will be generated but all previously added elements will still be in the collection. The collection will not be reverted to its state prior to starting the <code>addAll()</code>. If you need a reverted version of the collection, use <code>clone()</code> to make a copy before starting. Alternatively, if you set <code>suppressErrors=true</code>, <code>addAll()</code> will just omit any invalid content and continue without generating an error. This can be used to take a mixed collection and only copy the elements that match the target collection's type.</p> <p>Individual elements can be added to a map using <code>put</code>, which takes a key and a value as separate arguments, or <code>putPair()</code>, which takes a Pair object. There is not an option to put an element at a particular index in a map. Because a map has unique keys, adding an element with an existing key will replace it.</p> <p>To add multiple elements, use <code>putAll()</code>. This can only take an existing map. As with collections, if an element is invalid, an error will be generated but all previously added elements will still be in the map. <code>suppressErrors=true</code> can be used to just skip elements that are invalid.</p> <p><code>fromJson()</code> can be used to populate a collection or map that contains single-level scalar values. This function cannot be used for deserializing more complex objects. If that is not the case, either:</p> <ul> <li>Use VoltScript JSON Converter with a custom converter to convert the JSON array elements and then add to the collection using <code>add()</code>.</li> <li>Iterate the JSON object, converting each element and using <code>Map.put()</code>.</li> </ul>"},{"location":"howto/errorhandling.html","title":"Error Handling","text":""},{"location":"howto/errorhandling.html#uses-voltscript-logging","title":"Uses VoltScript Logging","text":"<p>VoltScript Collections makes use of VoltScript Logging, which provides the abilty to track and log error information.</p> <ul> <li>Documentation</li> <li>Source code</li> </ul>"},{"location":"howto/errorhandling.html#voltscript-collections-behavior","title":"VoltScript Collections Behavior","text":"<p>By default, VoltScript Collections classes will spawn <code>ErrorEntity</code> instances and add them to the global <code>ErrorSession</code> instance.  Developers can use information from these instances as determined by the Business Needs of their code.</p>"},{"location":"howto/errorhandling.html#suppress-errors-behavior","title":"Suppress Errors Behavior","text":"<p>The Collection and Map Classes within VoltScript Collections have a Boolean Property <code>suppressErrors</code>.  Setting this property to True will cause 2 distinct behaviors:</p> <ol> <li>ErrorEntity instances will not be spawned in situations where an internal error occurs (such as a type mismatch on a transform, etc).</li> <li>When Transforming or Adding elements, any matching type errors will be ignored, and the results of the action will contain only those elements with which there were no failures.</li> </ol> <p>Warning</p> <p>Certain programmatic actions, such as attempting to transform or modify a LOCKED instance (refer to the Collection or Map <code>isLocked</code> property), passing non-array JSON to the <code>fromJson</code> method, will ALWAYS throw an Error.  Setting <code>suppressErrors</code> to True will have no impact in these situations, it is up to the developer writing the calling code to avoid these situations. </p>"},{"location":"howto/filter.html","title":"Filter Collections / Maps","text":"<p>Filtering a collection or map is done using a CollectionFilter or a MapFilter. The steps that need to be done are:</p> <ol> <li>Create a class extending either CollectionFilter or MapFilter.</li> <li>Override the <code>filter()</code> method. This takes a single parameter (a variant for the current value in the collection, or a Pair for the current key/value pair in the map). It returns a boolean, for whether the entry should be copied into the new collection or map.</li> <li>Create an instance of the new class.</li> <li>Pass the instance to the Collection's or Map's <code>filter()</code> method.</li> </ol> <p>The <code>filter</code> methods will return a new Collection or Map, with the same settings as the original, containing the entries that passed the filter criteria. This means calls can be chained.</p>"},{"location":"howto/filter.html#sample-filter","title":"Sample Filter","text":"<p>A CollectionFilter class can be constructed like so:</p> <pre><code>Class EvenFilterer as CollectionFilter\n\n    Function filter(source as Variant) as Boolean\n        If (IsNumeric(source)) Then\n            If (source Mod 2 = 0) Then\n                Return True\n            End If\n        End If\n    End Function\n\nEnd Class\n</code></pre> <p>This EvenFilterer will only pass even numbers to the new Collection. The CollectionFilter class takes an empty constructor, so the only function that needs to be added is the <code>filter(source as Variant)</code> function that is being overridden, from line 3. The function needs to return a Boolean value, true if the element should be added to the new Collection and false if it should be omitted (filtered out).</p> <p>Line 4 checks the value passed in is numeric. Line 5 uses <code>Mod</code> to return the remainder from a division by 2 - any even number will return 0, any odd number will return 1. Thus only even numbers will return <code>true</code> from the function.</p> <p>This would then be implemented with the code:</p> <pre><code>Dim coll1 as New Collection(\"INTEGER\", Nothing, false, false)\nDim coll2 as Collection\nDim collFilter as New EvenFilterer()\n\nDim i as Integer\nFor i = 0 to 9\n    ' Create a random number, multiply by 100 and add just the integer portion\n    Call coll1.add(Fix(Rnd() * 100))\nNext\n\nSet coll2 = coll1.filter(collFilter)\n</code></pre> <p>The MapFilter is constructed and used in the same way, except its <code>filter()</code> method takes a key/value Pair object.</p>"},{"location":"howto/interrogate.html","title":"Interrogate the Collection / Map","text":""},{"location":"howto/interrogate.html#check-empty-or-size","title":"Check empty or size","text":"<p>The <code>hasContent</code> property can be used to check whether a collection or map is empty. Alternatively, if you just wish to know the number of elements in the Collection, use the <code>elementCount</code> property. <code>hasContent</code> internally checks against <code>elementCount</code>, which is updated for any insertion or removal operations.</p>"},{"location":"howto/interrogate.html#finding-an-element","title":"Finding an element","text":"<p>If you wish to check whether an element is already in the collection, the <code>contains()</code> method can be used. This will use the Comparator's <code>equals()</code> method to check the value being passed against the elements in the collection. For unsorted collections, this needs to iterate the whole collection. For sorted collection, the code can work out where the entry would need to be inserted, then check the entries before that point to see if one is unique.</p> <p>For maps, <code>containsKey()</code> will check whether the key is in the map. Because the keys are a Collection, it runs <code>Me.m_keySet.contains(keyVal)</code>. To check whether a value is in the map, <code>contains(checkValue as Variant, valueComparator as Comparator)</code> will iterate the values, comparing each using the passed Comparator. Obviously this needs to iterate the whole map, value by value.</p> <p>If you wish to know at which index an element is within the collection, the <code>getIndex()</code> method can be used. This will use the Comparator to check the value being passed against the elements in the collection. It will return a variant that is either the index or NULL. As a result, you will need to use <code>IsNull()</code> for safety.</p> <p>There is no provided function to get the position in the map for a value. If you have the key, the keyset is a Collection, so you can call its <code>getIndex()</code> method. Otherwise, you would need to iterate the map.</p>"},{"location":"howto/interrogate.html#getting-by-index","title":"Getting by index","text":"<p>You can get an element by position in the Collection by using <code>getNthElementRaw()</code>:</p> <ul> <li>To get the first element, use <code>getNthElementRaw(0)</code>.</li> <li>To get an element at 5th position, use <code>getNthElementRaw(4)</code> - remember the index starts at zero!</li> <li>To get the last element, use <code>getNthElementRaw(-1)</code>.</li> <li>Negative numbers can be used to count back from the end, so to get the penultimate entry, use <code>getNthElementRaw(-2)</code>.</li> </ul> <p>The same process of positive or negative numbers can be used to get keys or values in a map using <code>getNthKeyRaw()</code> or <code>getNthValueRaw()</code>.</p>"},{"location":"howto/iterate.html","title":"Iterate a Collection","text":"<p>You can use a <code>Do...Loop While</code> to iterate through the Collection and process the values.</p> <pre><code>Dim coll as New Collection(\"INTEGER\", Nothing, False, False)\nDim collval as Integer\nDim i as Long ' (1)\nCall coll.add(1)\nCall coll.add(2)\nCall coll.add(3)\nDo\n    collVal = coll.getNthElementRaw(i) ' (2)\nLoop While ++i &lt; coll.ElementCount\n</code></pre> <ol> <li>The index is 0-based and a Long. This is to accommodate Collections that are more than 32,767 elements.</li> <li>If the Collection contains objects you will need to use <code>Set</code>.</li> </ol> <p><code>i</code> is incremented at the end of the loop, before being compared to <code>coll.ElementCount</code>. Because the Collection is zero-indexed, <code>ElementCount</code> is one higher, so we check whether the next number we will iterate is greater than ElementCount.</p> <p>Maps can be iterated in the same way, using <code>getNthKeyRaw()</code> to get the key, <code>getNthValueRaw()</code> to get the value and <code>getNthPair()</code> to get the key/value Pair.</p>"},{"location":"howto/iterate.html#using-raw-output","title":"Using raw output","text":"<p>The output from the base Collection and map classes is a Variant. As a result, the value may need to be explicitly cast for the compiler to accept it. This is most commonly the case with objects. There are two options for this:</p> <ul> <li>Cast the Variant to the relevant class (e.g. <code>Set person = coll.getNthElementRaw(i)</code>).</li> <li>Cast the property explicitly (e.g. <code>myStr = coll.getNthElementRaw(i).firstName</code>).</li> </ul>"},{"location":"howto/iterate.html#preventing-modifications","title":"Preventing modifications","text":"<p>The <code>lock()</code> function will prevent modification of the collection until it is unlocked. This is useful if the collection is to be passed to another function, without the memory and performance overhead of cloning the collection first. For collections, the <code>lock()</code> function prevents the following functions from being used:</p> <ul> <li>add</li> <li>addAll</li> <li>clear</li> <li>fromJson</li> <li>getAndRemoveFirstRaw</li> <li>getAndRemoveLastRaw</li> <li>insertAt</li> <li>remove</li> <li>replace</li> <li>reverse</li> </ul> <p>For maps, the <code>lock()</code> function prevents the following functions from being used:</p> <ul> <li>clear</li> <li>fromJson</li> <li>getAndRemoveFirstPair</li> <li>getAndRemoveLastPair</li> <li>putAll</li> <li>put</li> <li>putPair</li> <li>removeByKey</li> <li>removeByValue</li> <li>reverse</li> </ul> <p>Warning</p> <p><code>Set coll = new Collection(...)</code> and <code>Set map = new Map(...)</code> will still re-initialize the collection or map, even if it is locked. This is because the <code>new()</code> function resets all variables to their defaults before running any code in the <code>new()</code> function, so there is no way to intercept and throw an error.</p> <p>Note</p> <p><code>clone()</code>, <code>filter()</code> and <code>transform()</code> can still be run on a locked collections and maps, because these functions do not modify the current object, instead they iterate the elements and create a new collection / map.</p>"},{"location":"howto/override.html","title":"Extend Collections / Maps","text":"<p>Often it might be easiest to just create an instance of the core Collection or Map classes. But there may be occasions where you want to extend the base classes.</p>"},{"location":"howto/override.html#overloading-the-constructor","title":"Overloading the constructor","text":"<p>Typically a custom collection or map class will know the type(s) of content it can accept and will not want to allow the developer to change that. An example of how to do that can be found in the StringCollection class. Obviously a StringCollection class should not allow the user to set the content type, so the number of parameters the constructor takes needs to change. As a result, the constructor for StringCollection is:</p> <pre><code>Public Sub New(comparator as Comparator, mustBeUnique as Boolean, isSorted as Boolean), Collection(\"STRING\", comparator, mustBeUnique, isSorted)\n\nEnd Sub\n</code></pre> <p>The structure of the method signature is:</p> <ol> <li>Public Sub New</li> <li>Parameters required for this class's constructor</li> <li>Comma</li> <li>The base class's name</li> <li>Arguments to pass to the base class's constructor</li> </ol>"},{"location":"howto/override.html#validating-content","title":"Validating content","text":"<p>The <code>continueAdd()</code> function validates that the content passed is an acceptable datatype. This uses <code>TypeName</code>. To change how your custom collection class identifies valid content, override this function.</p>"},{"location":"howto/override.html#extending-functions","title":"Extending functions","text":"<p>There will be rare occasions where you need to override an existing method, but still call the underlying functionality. This is done, for example, in StringCollection's <code>add()</code> method which casts the incoming value to a String for the ease of the developer and passes it to the base Collection class's <code>add()</code> method. The code for this is:</p> <pre><code>Public Function add(source as Variant) as Long\n    If (Not IsScalar(source)) Then\n        If me.suppressErrors Then Return -1\n        Error 1400, \"Cannot convert passed value to a String\"\n    Else\n        Return Collection..add(CStr(source))\n    End If\nEnd Function\n</code></pre> <p>This method is not accepting objects or arrays, so the <code>if</code> block from line 2 checks for that. If <code>suppressErrors</code> has been set to true, it just exits on line 3, otherwise throws an error on line 4.</p> <p>The interesting step comes on line 6. Firstly, it converts the incoming value to a string (<code>Cstr(source)</code>). Then this is passed to the same <code>add()</code> function being overridden. The syntax for this is BaseClass..methodName, so <code>Collection..add()</code>. We want to bubble up the result from the base <code>add()</code> method, so the result from the base class call is returned for this method as well.</p>"},{"location":"howto/override.html#returning-specific-object-types","title":"Returning specific object types","text":"<p>The <code>getNthElementRaw()</code> method returns a variant which, in some cases, may need casting before it can be used. If a custom Collection or Map class only accepts a specific type or types of object, it might be preferable to have a method that returns something other than a variant.</p> <p>The <code>getNthElementRaw()</code> method signature can't be changed, but a new method can be added and <code>getNthElementRaw</code> has been deliberately named to steer the developer towards an obvious choice - <code>getNthElement()</code>. Again the StringCollection class gives an example of how this can be done:</p> <pre><code>Public Function getNthElement(index as Long) as String\n    Return Cstr(getNthElementRaw(index))\nEnd Function\n</code></pre> <p>The new method signature returns a String, with its body converting the variant from <code>getNthElementRaw()</code> to a string.</p> <p>If your custom Collection or Map class contains objects of multiple types, you may need to return a common ancestor or just use the <code>getNthElementRaw()</code> class and cast in the calling code.</p>"},{"location":"howto/stack_queue.html","title":"Simulate a stack / queue","text":"<p>The Collection and Map classes both allow you to simulate the functionality of stacks and queues.</p> <p>For \"First In First Out\" functionality familiar from queues, Collection has a <code>getAndRemoveFirstRaw()</code> function and Map has a <code>getAndRemoveLastPair()</code> function.</p> <p>For \"Last In First Out\" functionality familiar from stacks, Collection has a <code>getAndRemoveLastRaw()</code> function and Map has a <code>getAndRemoveLastPair()</code> function.</p> <p>As when iterating a collection, for collections you may need to cast the result before using it.</p>"},{"location":"howto/string_json.html","title":"Convert to string or JSON","text":""},{"location":"howto/string_json.html#converting-to-strings","title":"Converting to strings","text":"<p>For collections of scalars, there is a <code>join()</code> function to join the elements into a single string with a specified delimiter separating the values. The <code>join()</code> function can't be used to join objects. However, when combined with <code>transform()</code> to convert the individual objects into strings, it means any Collection can be converted to a string of any format very easily.</p> <p>Maps don't have a <code>join()</code> function, but <code>collectValues()</code> and <code>transform()</code> can be used to manipulate the content into a suitable collection, from which <code>join()</code> can be used.</p>"},{"location":"howto/string_json.html#converting-to-json","title":"Converting to JSON","text":"<p>The <code>toJson()</code> method of Collection and Map will convert to the JsonVSE's JsonObject class. For collections, this will result in a JSON array. For maps, this will result in a JSON object. The <code>toJson()</code> method will work for scalar values as well as objects, as long as the corresponding class has a <code>toJson()</code> method.</p> <p>If objects don't have a <code>toJson()</code> method or need manipulating in some way, <code>transform()</code> can be used to convert each element in the Collection or Map before calling the <code>toJson()</code> method.</p>"},{"location":"howto/transform.html","title":"Transform Collections / Maps","text":"<p>Transforming a collection or map is done using a CollectionTransformer or a MapTransformer. The steps that need to be done are:</p> <ol> <li>Create a class extending either CollectionTransformer or MapTransformer.</li> <li>Override the <code>transform()</code> method. This takes two parameters. The first parameter is a variant for the current value in the collection, or a Pair for the current key/value pair in the map. The second parameter is the Collection or Map the transformed elements should be put in.</li> <li>Create an instance of the new class.</li> <li>Create an instance of a Collection or Map to hold the transformed elements.</li> <li>Pass the two variables to the Collection's or Map's <code>transform()</code> method.</li> </ol> <p>The transform is a Sub, so must be the last call in a chain.</p>"},{"location":"howto/transform.html#sample-transformer","title":"Sample Transformer","text":"<p>A CollectionTransformer class can be constructed like so:</p> <pre><code>Class DoubleTransformer as CollectionTransformer\n\n    Function transform(source as Variant) as Variant\n        If (IsNumeric(source)) Then\n            If (Not TypeName(source) = \"BOOLEAN\" And Not IsDate(source)) Then\n                transform = CDbl(source)\n            End If\n        End If\n    End Function\n\nEnd Class\n</code></pre> <p>The DoubleTransformer will convert the input to a Double, skipping values that cannot be converted to a numeric or are booleans or dates. The CollectionTransformer class takes an empty constructor, so the only function that needs to be added is the <code>transform(source as Variant)</code> function that is being overridden, from line 3. If no value is returned, the value will not be added to the new Collection.</p> <p>Line 4 checks if the value passed in is numeric or can be converted to a number. Line 5 excludes values that are booleans or dates.</p> <p>This would then be implemented with the code:</p> <pre><code>Dim coll1 as New Collection(\"SCALAR\", Nothing, false, false)\nDim coll2 as New Collection(\"DOUBLE\", Nothing, true, true)\nDim numTransformer as New DoubleTransformer()\n\n' Populate coll1\n\nCall coll1.transform(numTransformer, coll2)\n</code></pre> <p>Line 2 creates a second Collection, only accepting Doubles, only including unique values and sorted. Line 3 creates the DoubleTransformer instance. The code to populate <code>coll1</code> is omitted, it would appear in place of the comment on line 5. Line 7 then calls the <code>transform()</code> function on <code>coll1</code>, passing the converted values into coll2 and skipping any values that cannot be converted to a numeric or are dates or booleans.</p> <p>The MapFilter is constructed and used in the same way, except its <code>filter()</code> method takes a key/value Pair object as its first argument.</p>"},{"location":"references/index.html","title":"References","text":"<p>References provide technical references and descriptions for VoltScript Collections.</p>"},{"location":"references/index.html#repository-structure","title":"Repository structure","text":"<ul> <li>All the code for the framework itself is in <code>src/VoltScriptCollections.vss</code>.</li> <li>A set of unit tests for validating the code can be found in the <code>test</code> directory.</li> <li><code>runAllTests.vss</code> is a script file that can be run to verify all tests pass. Output will be written to <code>unit-test-reports</code> directory. index.md</li> </ul>"},{"location":"references/index.html#api-documentation","title":"API Documentation","text":"<p>Full API Documentation for VoltScript Collections</p>"},{"location":"references/index.html#test-reports","title":"Test reports","text":"<ul> <li>Collections Tests</li> <li>Map Tests</li> </ul>"},{"location":"references/index.html#documentation-and-source-code","title":"Documentation and source code","text":"<ul> <li>HCL Volt MX Go Documentation</li> <li>VoltScript</li> <li>VoltScript Testing<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript JSON Converter<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Console Colors<ul> <li>Source code</li> </ul> </li> <li>VoltScript Interface Designer<ul> <li>Documentation</li> </ul> </li> <li>VoltScript Volt MX Middleware<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Logging<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> </ul>"},{"location":"references/index.html#support","title":"Support","text":"<p>To share information, ask questions, and learn about VoltScript Collections, go to the Community.</p>"},{"location":"topicguides/index.html","title":"Topic guides","text":"<p>Topic guides discuss and explain topics and concepts about VoltScript Collections to help you gain a better understanding of how it works.</p> <ul> <li>Why VoltScript Collections and Maps?</li> <li>Valid Content Types</li> <li>Sorting</li> <li>Pair Class</li> <li>Understanding Collection Sorting Performance</li> </ul>"},{"location":"topicguides/pair.html","title":"Pair Class","text":"<p>Pair is a basic class consisting of a key and a value, used for an element in a Map.</p> <p>It's immutable, which means that the key and value can't be changed once it's created. They can be accessed via dot notation, but are read only properties. They must be set with the constructor.</p> Sample Code<pre><code>    Dim map as New Map(\"STRING\", Nothing, False) '(1)\n    Dim pair as New Pair(\"Hello\", \"World\")\n    Call map.putPair(pair)\n    Set pair = New Pair(\"John\", \"Doe\")\n    Print map.getNthPair(0).key &amp; \", \" &amp; map.getNthPair(0).value\n</code></pre> <ol> <li>Creates a new Collection which can contain any value or object, is unsorted and not unique</li> </ol> <p>Line 4 replaces the old Pair object with a new one with the values <code>\"John\", \"Doe\"</code>. However, this doesn't change the previously created Pair object created on line 2 and added into the Map at line 3. So line 5 prints out \"Hello, World\"</p>"},{"location":"topicguides/size_and_performance.html","title":"Understanding Collection Sorting Performance","text":""},{"location":"topicguides/size_and_performance.html#internal-structure-of-collections-and-maps","title":"Internal structure of Collections and Maps","text":"<p>Collections store their content in an internal Variant List. The ListTag (key) is the position (zero-indexed), as a Long. The value is the value being put into the collection. This means a collection can surpass the bounds of an array, does not need to have its size redeclared when adding elements, but is still performant.</p> <p>The downside is that when removing values, all subsequent entries need their ListTag to be updated.</p> <p>Maps use a collection (with an internal Variant List) for the keys, and an internal Variant List for the values. The map's List of values has the key as its ListTag and the value as the value. Thus the map is a List, with a separate List for its order.</p>"},{"location":"topicguides/size_and_performance.html#sorting-searching-algorithm","title":"Sorting / searching algorithm","text":"<p>If the collection or map is unsorted, insertion is done by just adding a new element at the next index. The index is easily determined, because it is the element count. Although insertion is quicker, any operation that needs to find a specific element by value is slower. This is because it needs to iterate all elements in the collection.</p> <p>If the collection or map is sorted, insertion is done in three steps. If the entry should go before the first entry, we do that. If the entry should go after the last entry, we do that. Otherwise, we chunk and reduce the chunk size until the relevant position is found. Using collections of various sizes, the most performant approach found was to chunk with a divisor of 4. So chunks are <code>(divisor * interval) + 1</code>, so:</p> <ul> <li>1 (0 * 4 + 1)</li> <li>5 (1 * 4 + 1)</li> <li>21 (5 * 4 + 1)</li> <li>85 (21 * 4 + 1)</li> <li>341 (85 * 4 + 1)</li> <li>1405 (341 * 5 + 1)</li> <li>etc</li> </ul> <p>The process starts at the largest chunk size that is lower than the number of elements. It then finds which chunk the entry should go before, reduces the chunk using <code>(interval - 1) / divisor</code> and repeats. So for a collection of 100, it will:</p> <ul> <li>Find which chunk of 85 the entry should go before.</li> <li>Find which chunk of 21 the entry should be before.</li> <li>Find which chunk of 5 the entry should go before.</li> <li>Find which entry (chunk of 1) the entry should go before.</li> </ul> <p>This process can be used to quickly identify where a new entry should be inserted and where an existing entry can be found.</p>"},{"location":"topicguides/size_and_performance.html#filtering-and-transforming","title":"Filtering and transforming","text":"<p>Both filtering and transforming is done by iterating the collection or map and processing each entry. If not empty / null, the relevant output - the current entry (filter) or modified output (transform) - is put in the resulting collection or map. As a result, when there is a requirement to filter and transform a collection or map, it may be more efficient to just use a transformer and return an invalid or empty object, while suppressing errors in the resulting collection.</p>"},{"location":"topicguides/sorting.html","title":"Sorting and Comparators","text":"<p>The VoltScript collections and maps are not sorted as a retrieval operation but ordered during insertion.</p>"},{"location":"topicguides/sorting.html#default-ordering","title":"Default ordering","text":"<p>By default entries are ordered on insertion order. The first entry added will be at index 0, the second at index 1 etc. If the collection or map is reversed, the first entry now be at the last index, the second and the penultimate index etc.</p>"},{"location":"topicguides/sorting.html#overriding-insertion-ordering-sorted-collections-maps","title":"Overriding insertion ordering (sorted Collections / Maps)","text":"<p>To override insertion order, the developer needs to do two things:</p> <ul> <li>The <code>isSorted</code> argument in the collection or map's constructor must be set to <code>True</code> (e.g. <code>Dim coll as New Collection(\"SCALAR\", Nothing, False, True)</code>)</li> <li>The collection or map needs a Comparator passing as the second argument. If <code>Nothing</code> is passed, an instance of the base Comparator class will be used, see below.</li> </ul> <p>The collection does not define whether it is ordered ascending or descending (e.g. for strings A-Z vs Z-A, for numbers 1 to 1000 vs 1000 to 1). This is defined using the argument when creating the Comparator instance (e.g. <code>Dim comp as New Comparator(False)</code> orders ascending, <code>Dim comp as New Comparator(True)</code> orders descending).</p>"},{"location":"topicguides/sorting.html#reversed-collections-and-sort-order","title":"Reversed collections and sort order","text":"<p>By storing sort order separately in the Comparator, it means a single <code>compare()</code> method can be used irrespective of the sort order. A separate <code>compareAscDesc()</code> method will handle reversing the sort result, depending on <code>isDescending</code> or if the Map / Collection is reversed. So creating a custom Comparator is as simple as adding the constructor and creating a <code>compare()</code> method, returning the appropriate value based on ascending comparison.</p> <p>The <code>compareAscDesc()</code> function uses <code>Xor</code> to flip the compare result if the collection is reversed or the sort order is descending, but not if collection is reversed and the sort order is descending. This is tested in <code>testSortedNumerics()</code> in collectionUnitTests.</p> <p>So assume the collection contains the number 12 and we're adding 13.</p> Collection Reversed Comparator Ascending / Descending Result Order No Asc 1 (After) 12, 13 Yes Asc -1 (Before) 13, 12 No Desc -1 (Before) 13, 12 Yes Desc 1 (After) 12, 13"},{"location":"topicguides/sorting.html#base-comparator","title":"Base comparator","text":"<p>The base Comparator class handles any scalar values. The values are ordered first on datatype (using a private <code>compareDataType()</code> function), then within the datatype (using a private <code>compareMatchingDataType()</code> function). In the <code>compareDataType()</code> function, numerics are grouped together, so an Integer (datatype 2) with a value of 13 with come after a Double (datatype 5) with a value of 2.5. A String with value \"1\" will come after all the numerics. If the source and target are the same grouped datatype, the comparison uses the same function as the MatchingDataTypeComparator.</p>"},{"location":"topicguides/sorting.html#matchingdatatypecomparator","title":"MatchingDataTypeComparator","text":"<p>The MatchingDataTypeComparator handles scalar values but expects values to be of the same data type and uses the private <code>compareMatchingDataType()</code> function. If the stringified values are identical, it will return 0. Otherwise, variables can complicate comparison because of floating-point precision errors. Using <code>CStr()</code> prevents this, but then \"12.56\" will come before \"9.25\". So for numerics, the code compares the integer portion first, then the stringified fractional portion. For non-numerics, just the stringified value is compared.</p>"},{"location":"topicguides/sorting.html#compare-and-equals-functions","title":"compare() and equals() Functions","text":"<p>Sorting uses the <code>compare()</code> function. But the comparator also need to determine equality. A single function could be used, but this would not necessarily fulfill the requirements of objects, where sorting may be based on one or more properties, but equality may be determined simply on a primary key for the object or may require testing every property.</p> <p>Even for basic scalars, the logic for the <code>compare()</code> function and the <code>equals()</code> function will differ. For the MatchingDataTypeComparator, for example, the <code>equals()</code> function can just compare the stringified values and return true / false. But the <code>compare()</code> function needs to go further and check whether the source if before or after the target value.</p> <p>As a result, there are two functions:</p> <p>compare is used for:</p> <ul> <li>add / put (sorted collections)</li> <li>addAll / putAll (sorted collections)</li> </ul> <p>equals is used for:</p> <ul> <li>contains()</li> <li>getIndex()</li> <li>remove()</li> <li>replace()</li> <li>add / put (unique collections)</li> <li>addAll / putAll (unique collections)</li> </ul>"},{"location":"topicguides/valid.html","title":"Valid Content Types","text":"<p>VoltScript Collections classes are more strongly-typed than basic Arrays and Lists, and as such some restrictions have had to be placed on the allowable content types.  </p> <p>The reasons behind these restrictions are fairly numerous, but ultimately can be distilled down to the following four:</p> <ol> <li>Focus on simplicity and ease of use.</li> <li>Code complexity for comparing Collection or Map elements.</li> <li>Tests for Sorting or Uniqueness of elements.</li> <li>Code efficiency and speed.</li> </ol> <p>Because of this, the ContentType must be declared when instantiating a Collection or Map.</p> <p>Nearly all Content Types are allowed</p> <p>Explicitly Allowed Content Types</p> <ul> <li>STRING, INTEGER, LONG, SINGLE, DOUBLE, CURRENCY, DATE/TIME, BOOLEAN, BYTE</li> <li>Any defined class name.</li> <li>SCALAR or OBJECT (generically allows Scalar or Object instances)</li> </ul> <p>Multiple Content Types</p> <p>Collections and Maps can optionally contain multiple data types, as long as they are Scalar or Object compatible. Multiple content types are declared using a comma delmited string -refer the Constructor methods in the API documentation</p> <p>However the following restrictions exist</p> <p>Content Type RESTRICTIONS</p> <ul> <li>VARIANT: Calling TypeName() on a Variant returns the data type of the value and not the declaration. This means there is no effective way to determine if a variable has been declared as a Variant.  </li> <li>Mixing SCALAR with any other element type</li> <li>Mixing OBJECT with any other element type </li> <li>Mixing any of the Scalar types with any Class Object type</li> <li>NULL, EMPTY, NOTHING, ARRAY, or LIST. </li> </ul> <p>Violating the above restricitons will result in a run-time error for the ContentType.</p> <p>Comparison without Introspection and Reflection</p> <p>Because VoltScript language lacks Type Introspection or Reflective capabilities, creating generic code to compare object instances is inherently risky and can quickly become quite complex.</p> <p>It is up to the developer using VoltScript Collections to know and understand the necessary properties and methods of any Class objects they intend to use as elements within a Collection or Map, and how to compare such instances when extending the Comparator class to Create their own comparator. </p>"},{"location":"topicguides/why.html","title":"Why VoltScript Collections and Maps?","text":"<p>Warning</p> <p>VoltScript is designed for middleware, so any data has to be retrieved over HTTP(S). As a result, optimizing performance for large collections is not a priority for the framework, because performance will always be compromised for large collections in retrieving the data from whatever database it resides in and / or sending the data to the end user.  This means you need to work with smaller sets of data to maximize performance.</p> <p>Historically, the core LotusScript and VoltScript languages have had Arrays and Lists.</p> <p>Arrays vs Lists</p> <p> Arrays  - can contain any data type, including classes and Lists. - are unsorted. - are not unique. - are 0 indexed (unless <code>Option Base</code> is used, not recommended). - allow access based on index or via iteration. - ArrayGetIndex returns a Variant, which is numeric if the element is in the index and NULL if not. Lists - can contain any data type, including classes and Lists. - are a keyed unsorted map with string keys. - have unique keys. - require <code>IsElement()</code> to check for existence. - allow access based on key or via <code>ForAll</code> iteration. - require looping via <code>ForAll</code> iteration to get element count - Requires <code>Erase</code> to remove an element or the entire list from memory. </p> <p>While Arrays and Lists are very useful, they are not as robust as the collection handling found in modern programming languages.</p>"},{"location":"topicguides/why.html#voltscript-collections-classes","title":"VoltScript Collections classes","text":"<p>The key focus areas for VoltScript Collections are simplicity and ease of use.  These classes provide:</p> <ul> <li>Simple classes for collections and maps.</li> <li>Clearly defined Valid Content Types</li> <li>The Pair class: the basis of an element in a map, but also simple dictionary data types.</li> <li>isSorted and isUnique options for collections.</li> <li>isSorted options for maps (maps are always unique).</li> <li>A basic comparator that works for scalars without the developer needing to pass anything.</li> <li>A simple comparator to compare based on the same datatype.</li> <li>Extensible comparators for sorting and uniqueness. The Comparator defines sort order (ascending or descending) and is used to check for matches on <code>getIndex()</code>, <code>contains()</code>, <code>remove()</code> and <code>replace()</code> operations.</li> </ul> <p>The two primary classes which most closely resemble Arrays and Lists are are Collection and Map.</p> <p>Collection vs Map</p> <p> Collection  - can contain almost any data type, including class instances. - elements can be sorted or unsorted. - elements can be unique or non unique. - are 0 indexed. - allow access based on index or via indirect iteration (using the <code>getAndRemoveXXX</code> methods). - <code>getIndex</code> returns a Variant, which is numeric if the element is in the index and NULL if not. Map - can contain almost any data type, including class instances. - are keyed using VoltScript scalars (<code>String</code>, <code>Integer</code>, <code>Long</code>, <code>Single</code>, etc) - have unique keys. - uses <code>contains()</code> to check for element existence. - allow access based on key, or indirectly by using one of the <code>getNthXXX</code> or <code>getAndRemoveXXX</code> methods. - elements can be removed by using one of the <code>removeByXXX</code> methods. </p> <p>Some of the common operations for Collections and Maps are:</p> <ul> <li><code>reverse()</code> method on collections and maps to change sort order. Subsequent additions honor the amended sort order.</li> <li><code>getIndex()</code>, <code>remove()</code> and <code>replace()</code> methods to manipulate collections, with relevant methods also for maps.</li> <li><code>join()</code> method on collections to create string of scalars.</li> <li><code>toJson()</code> and <code>fromJson()</code> methods.</li> <li><code>filter()</code>, <code>clone()</code> and <code>transform()</code> methods to manipulate collections and maps.</li> <li><code>lock()</code> and <code>unlock()</code> methods to prevent inadvertent changes when passing to other functions.</li> <li><code>collectValues()</code> method to convert map values into a collection.</li> <li><code>collectKeys()</code> method to retrieve map keys as a collection.</li> <li><code>getAndRemoveFirst()</code> methods to provide the functionality of a Queue (FIFO).</li> <li><code>getAndRemoveLast()</code> methods to provide the functionality of a Stack (LIFO).</li> </ul>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>Tutorials give hands-on introduction on how to use VoltScript Collections.</p>"},{"location":"tutorials/index.html#collections","title":"Collections","text":"<ul> <li>Simple Collection examples</li> <li>Filters, Transformers, Custom Comparators and Custom Collections</li> </ul>"},{"location":"tutorials/index.html#maps","title":"Maps","text":"<ul> <li>Simple map examples</li> <li>Filters, Transformers, Custom Comparators</li> </ul>"},{"location":"tutorials/1-simpleCollection.html","title":"Simple Collection Examples","text":""},{"location":"tutorials/1-simpleCollection.html#unsorted-and-non-unique","title":"Unsorted and Non-Unique","text":"<p>With the following code you can create an unsorted, non-unique Collection and print out the contents:</p> <pre><code>Dim coll as New Collection(\"SCALAR\", Nothing, False, False)\nDim i as Long ' (1)!\nDim j as Long\nDim dbls(3) as Double\n\nCall coll.add(\"Hello\")\nCall coll.add(\"World\")\nCall coll.add(1)\nCall coll.add(2)\nCall coll.add(3)\nCall coll.add(\"Hello\")\n\ndbls(0) = 1.23\ndbls(1) = 21.648\ndbls(2) = 8472.6\ndbls(3) = 746.0\nCall coll.addAll(dbls)\n</code></pre> <ol> <li>The index is 0-based and a Long. This is to accommodate Collections that are more than 32,767 elements.</li> </ol> <p>On line 1 you instantiate a Collection that can contain any scalar value and is unsorted and can contain duplicate elements. On lines 5 to 10, you add values individually. You then populate a double array on lines 12 to 15, and use <code>addAll()</code> to add them in a single call into the Collection.</p> <p>You can use a <code>Do...Loop While</code> to iterate through the Collection and print out the values.</p> <pre><code>Do\n    Print coll.getNthElementRaw(i)\nLoop While ++i &lt; coll.ElementCount\n</code></pre> <p><code>i</code> is incremented at the end of the loop, before being compared to <code>coll.ElementCount</code>. Because the Collection is zero-indexed, <code>ElementCount</code> is one higher, so you check whether the next number you will iterate is greater than ElementCount. They're printed according to insertion order.</p> <p>But you can insert an element at a particular index.</p> <pre><code>Call coll.insertAt(\"New\", 1)\nPrint coll.join(\",\")\n</code></pre> <p>The printed out content will now output \"Hello,New,World,1,2,3,Hello,1.23,21.648,8472.6,746\", with the word \"New\" inserted as the second element.</p>"},{"location":"tutorials/1-simpleCollection.html#sort-and-unique","title":"Sort and Unique","text":"<p>With the following code you can create a unique and sorted Collection:</p> <pre><code>Dim coll2 as New Collection(\"SCALAR\", Nothing, True, True)\n\nCall coll2.add(\"Hello\")\nCall coll2.add(\"World\")\nCall coll2.add(1)\nCall coll2.add(2)\nCall coll2.add(3)\nCall coll2.add(2.5)\nCall coll2.add(\"Hello\")\n</code></pre> <p>When you iterate this Collection, the numeric values will be inserted at the start of the Collection and the strings at the end. Integers and doubles will be treated as the same data-type, so 2.5 will appear between 2 and 3. The duplicate \"Hello\" will be ignored. When you iterate the Collection to print the values out, you will get:</p> <pre><code>1\n2\n2.5\n3\nHello\nWorld\n</code></pre> <p>Note</p> <p><code>insertAt()</code> will generate an error if you try to use it, because you have specfied that the Collection should be sorted.</p>"},{"location":"tutorials/1-simpleCollection.html#reversing-and-adding","title":"Reversing and Adding","text":"<p>You can reverse the Collection and adding will still add elements into the correct location:</p> <pre><code>Call coll2.reverse()\nCall coll2.add(1.5)\n\nDo\n    Print coll.getNthElementRaw(i)\nLoop While ++i &lt; coll.ElementCount\n</code></pre> <p>This will now print:</p> <pre><code>World\nHello\n3\n2.5\n2\n1.5\n1\n</code></pre> <p>Example Code</p>"},{"location":"tutorials/1-simpleMap.html","title":"Simple map examples","text":""},{"location":"tutorials/1-simpleMap.html#unsorted-map","title":"Unsorted Map","text":"<p>There are many examples of unsorted maps across all technologies, whether that be Java HashMaps, JSON objects or even various settings files. With the following code you can create an unsorted Map and print out the contents:</p> <pre><code>Dim map as New Map(\"STRING\", Nothing, False)\nDim i as Long ' (1)\n\nCall map.put(\"AZ\", \"Arizona\")\nCall map.put(\"FL\", \"Florida\")\nCall map.put(\"IO\", \"Iowa\")\nCall map.put(\"NE\", \"Nebraska\")\nCall map.put(\"PA\", \"Pennsylvania\")\nCall map.put(\"AL\", \"Alabama\")\n\nDo\n    Print map.getNthValueRaw(i)\nLoop While ++i &lt; map.elementCount\n</code></pre> <ol> <li>The index is 0-based and a Long. This is to accommodate Collections that are more than 32,767 elements.</li> </ol> <p>On line 1, you instantiate the Map to hold strings, but be unsorted. On lines 4 to 9, you populate the map. You use a <code>Do...Loop While</code> to iterate through the map and print the values. <code>i</code> is incremented at the end of the loop, before being compared to <code>coll.ElementCount</code>. Because the Collection is zero-indexed, <code>ElementCount</code> is one higher, so you check whether the next number you will iterate is greater than ElementCount. They're printed according to insertion order.</p> <p>If you add another element and print again, the new element appears at the end of the Map:</p> <pre><code>Call map.put(\"CA\", \"California\")\n\nDo\n    Print map.getNthValueRaw(i)\nLoop While ++i &lt; map.elementCount\n</code></pre>"},{"location":"tutorials/1-simpleMap.html#sorted-map","title":"Sorted Map","text":"<p>You can't change this Map to be sorted. But to sort the elements, you can create a new sorted Map and copy all the elements across.</p> <pre><code>Dim map2 as New Map(\"STRING\", Nothing, True) ' (1)!\nCall map2.putAll(map)\n</code></pre> <ol> <li>The second parameter, <code>Nothing</code> means the basic scalar comparator will be used. Before checking the value, this will also check the datatype, which is unnecessary but has minimal overhead for a small map like this.</li> </ol> <p>This time, the printout will be \"Alabama,Arizona,California,Florida,Iowa,Nebraska,Pennsylvania\", with the states sorted alphabetically on their state codes.</p> <p>If you add another element, it will appear in the relevant sorted location. So if you do <code>Call map2.put(\"NY\", \"New York\")</code> and print again, \"New York\" will appear after \"Nebraska\" and before \"Pennsylvania\".</p>"},{"location":"tutorials/1-simpleMap.html#reversing-and-adding","title":"Reversing and Adding","text":"<p>You can reverse the Map and adding elements will still make them appear in the expected position:</p> <pre><code>Call map2.reverse()\nCall map2.put(\"WA\", \"Washington\")\n\nDo\n    Print map2.getNthValueRaw(i)\nLoop While ++i &lt; map2.elementCount\n</code></pre> <p>\"Washington\" will appear as the first element of the Map, because it's now sorted in reverse alphabertical order.  Finding Elements in a Map</p> <p>You can check for the existence of an element either by trying to return a value by the key or using <code>contains</code> methods.</p> <pre><code>If (IsEmpty(map2.getValueRawByKey(\"CO\"))) Then\n    Print \"Could not find CO\"\nElse\n    Print \"Found CO\"\nEnd If\n\nIf (map2.containsKey(\"NY\")) Then\n    Print \"Found NY\"\nElse\n    Print \"Could not find NY\"\nEnd If\n\nIf (map2.contains(\"Las Vegas\", Nothing)) Then\n    Print \"Found Las Vegas\"\nElse\n    Print \"Could not find Las Vegas\"\nEnd If\n</code></pre> <p>In the first if statement, you try to return the value for a passed key and check whether you get a value back. In the second if statement, you pass the key to the <code>containsKey</code> function. In the last if statement, you check whether the map contains a specific value, using a basic scalar comparator to compare against each value.</p> <p>Note</p> <p>The <code>contains</code> methods will need to iterate and use a Comparator in order to try to return an answer. <code>getValueRawByKey()</code> will just go directly to the element matching that key.</p> <p>Example Code</p>"},{"location":"tutorials/2-filterCollection.html","title":"Filters, Transformers, Custom Comparators and Custom Collections","text":""},{"location":"tutorials/2-filterCollection.html#person-class","title":"Person Class","text":"<p>Imagine you have a class like so:</p> <pre><code>Class Person\n\n    Public firstName as String\n    Public lastName as String\n    Public age as Integer\n\nEnd Class\n</code></pre>"},{"location":"tutorials/2-filterCollection.html#loading-basic-person-collection","title":"Loading Basic Person Collection","text":"<p>You can populate a collection like so:</p> <pre><code>Dim personColl as New Collection(\"PERSON\", Nothing, False, False)\nCall personColl.add(createPerson(\"Dennis\", \"Doe\", 84))\nCall personColl.add(createPerson(\"Denise\", \"Doe\", 82))\nCall personColl.add(createPerson(\"Andrew\", \"Doe\", 65))\nCall personColl.add(createPerson(\"Fred\", \"Doe\", 65))\nCall personColl.add(createPerson(\"Frances\", \"Doe\", 67))\nCall personColl.add(createPerson(\"John\", \"Doe\", 42))\nCall personColl.add(createPerson(\"Jane\", \"Doe\", 30))\nCall personColl.add(createPerson(\"Johnathan\", \"Doe\", 12))\nCall personColl.add(createPerson(\"Janet\", \"Doe\", 6))\nCall personColl.add(createPerson(\"Ken\", \"Doe\", 41))\nCall personColl.add(createPerson(\"Karen\", \"Doe\", 39))\nCall personColl.add(createPerson(\"Bill\", \"Doe\", 19))\nCall personColl.add(createPerson(\"Bob\", \"Doe\", 17))\nCall personColl.add(createPerson(\"Ben\", \"Doe\", 10))\n</code></pre> <p>On the first line, you create a Collection that will only accept <code>Person</code> objects, but will be non-unique and unsorted.</p> <p>Imagine the feed of data you have is based on a family tree format: Dennis and Denise had twins - William and Fred; William did not marry, but Fred married Frances and had two sons, John and Ken; John married Jane and had two children; Ken married Karen and had three children.</p> <p>You add each Person object in turn to the Collection. For brevity of code, you do this using a function:</p> <pre><code>Function createPerson(firstName as String, lastName as String, age as Integer) as Person\n\n    Set createPerson = new Person()\n    createPerson.firstName = firstName\n    createPerson.lastName = lastName\n    createPerson.age = age ' (1)!\n\nEnd Function\n</code></pre> <ol> <li>The Person object, assigned to a variable with the same name as the function, is implicitly returned at the end of the function.</li> </ol>"},{"location":"tutorials/2-filterCollection.html#filter-and-comparator","title":"Filter and Comparator","text":"<p>You now have a Collection of Person objects based on insertion order. It may be that our code needs to perform some function with those or generate some reporting. But imagine at some point in the processing, you then want to filter out those Person entries with an age greater of 80 or more, and sort the rest on age, then first name.</p>"},{"location":"tutorials/2-filterCollection.html#personfilter","title":"PersonFilter","text":"<p>To filter out entries, you extend the CollectionFilter class with a PersonFilter class. The CollectionFilter class has an empty constructor, so you don't need to specify the New method. But you do want to override the <code>filter()</code> method. In this case, you want to return true only if the age is less than 80.</p> <pre><code>Class PersonFilter as CollectionFilter\n\n    Function filter(source as Variant) as Boolean\n        Return CInt(source.age) &lt; 80\n    End Function\n\nEnd Class\n</code></pre>"},{"location":"tutorials/2-filterCollection.html#personcomparator","title":"PersonComparator","text":"<p>The sort options for a Collection can't be changed once it's created, and the <code>filter()</code> method uses the same settings as the Collection it's filtering. But you can add the entries to a new Collection that's sorted. To sort, you need to create a custom Comparator.</p> <p>This can be done with:</p> <pre><code>Class PersonComparator as Comparator\n\n    Sub New(isDescending as Boolean)\n        'Nothing needed here\n    End Sub\n\n    Function compare(source as Variant, target as Variant) as Integer\n        Dim person1 as Person\n        Dim person2 as Person\n        Dim check as Integer\n\n        Set person1 = source\n        Set person2 = target\n        If (person1.age &lt; person2.age) Then \n            Return -1\n        ElseIf (person1.age &gt; person2.age) Then\n            Return 1\n        Else\n            check = StrCompare(Person1.firstName, person2.firstName, 0)\n            If (check = 0) Then check = StrCompare(Person1.lastName, person2.lastName, 0)\n            Return check\n        End If\n    End Function\n\n    Function equals(source as Variant, target as Variant) as Boolean\n        If compare(source, target) = 0 Then Return True\n    End Function\n\nEnd Class\n</code></pre> <p>The Comparator class doesn't have an empty constructor, so you need to explicitly add the constructor, from line 3. However, both constructors have the same arguments, so the code is very simple and it will automatically call the <code>Comparator</code> class's <code>New</code> method.</p> <p>From line 7, you override the <code>compare</code> method. This method takes two parameters - <code>source</code>, the value being inserted, and <code>target</code>, the value it's being compared to. On lines 12 and 13, you explicitly cast source and target as Person objects. This means the runtime automatically understands the data type of the properties, so you don't need to explicitly convert to doubles or strings.</p> <p>If the ages are different, it's simple. On lines 14 and 15, we return -1 (\"before\") if the age on the source Person object is less than the target Person object. On lines 16 and 17, you return 1 (\"after\") if the age of the source Person object is greater than the target Person object. The <code>compare</code> method is used for uniqueness as well as sort order, so you can't just return 0 in all other cases. you need to check the first name and, if that's still 0, check the last name.</p> <p>Because we're going to use the Comparator for a unique collection, we need to override the <code>equals()</code> function to return <code>True</code> if we find an exact match. The <code>compare()</code> function returns an integer where 0 means it's an exact match, so we can reuse that function.</p>"},{"location":"tutorials/2-filterCollection.html#passing-to-sorted-collection","title":"Passing to Sorted Collection","text":"<p>Now you are ready to filter the Collection and pass it to a sorted Collection.</p> <p>Note</p> <p>Running a filter iterates the source Collection and returns a new Collection. Adding the resulting (filtered) Collection to a new sorted Collection also requires iterating the Collection. For a small Collection, the performance overhead will be minimal and there may be benefits for debugging in having multiple steps.</p> <pre><code>    Dim filter as New PersonFilter()\n    Dim compar as New PersonComparator(false)\n    Dim sortedPersonColl as New Collection(\"PERSON\", compar, True, True)\n\n    Call sortedPersonColl.addAll(personColl.filter(filter))\n</code></pre> <p>On line 1, you create an instance of the PersonFilter. On line 2 you create an instance of the PersonComparator, telling it to sort in ascending order (youngest to oldest, then first name A-Z). On line 3, you create a sorted, non-unique Collection passing in the PersonComparator for sorting and identifying uniques.</p> <p>Finally, on line 5, you perform the process. <code>personColl.filter(filter)</code> is called first, returning a filtered Collection. The resulting Collection is then passed to <code>Call sortedPersonColl.addAll()</code>.</p>"},{"location":"tutorials/2-filterCollection.html#transformer-and-custom-collection","title":"Transformer and Custom Collection","text":"<p>Imagine you want to output summary data about the people, hiding their actual age but just defining age groups - child, young person, adult, pensioner. Imagine the code already has a class for Person information in this format, like so:</p> <pre><code>Class PersonAlt\n\n    Public fullName as String\n    Public ageRange as String\n\nEnd Class\n</code></pre> <p>A CollectionTransformer can convert from one class to the other.</p>"},{"location":"tutorials/2-filterCollection.html#persontransformer","title":"PersonTransformer","text":"<p>You just need to create a PersonTransformer extending the CollectionTransformer class, like so:</p> <pre><code>Class PersonTransformer as CollectionTransformer\n\n    Function transform(source as Variant) as Variant\n        Dim newPerson as new PersonAlt()\n        Dim oldPerson as Person\n\n        Set oldPerson = source\n        newPerson.fullname = oldPerson.firstName &amp; \" \" &amp; oldPerson.lastName\n        Select Case oldPerson.age\n            Case Is &lt; 18:\n                newPerson.ageRange = \"Child\"\n            Case 16 To 30\n                newPerson.ageRange = \"Young Person\"\n            Case Is &gt; 60\n                newPerson.ageRange = \"Pensioner\"\n            Case Else\n                newPerson.ageRange = \"Adult\"\n        End Select\n        Return newPerson\n    End Function\n\nEnd Class\n</code></pre> <p>The CollectionTransformer has an empty constructor, so we don't need to include the <code>Sub New</code>. We just need to extend the <code>transform</code> function, from line 3. This takes an incoming value as a Variant (<code>source</code>) and returns the transformed value as a Variant.</p> <p>For readability, you create a <code>newPerson</code> on line 4 using the <code>PersonAlt</code> class you need to output. And you declare an <code>oldPerson</code> object on line 5 as the <code>Person</code> class you expect incoming. On line 7, you explicitly cast <code>source</code> into the <code>oldPerson</code> object.</p> <p>On line 8, you set the <code>fullName</code> property.</p> <p>From line 9, you have a <code>Select Case</code> statement to convert age to a textual range value. Lines 10 and 14 use <code>Is</code> with a comparison operator, to identify children or pensioners. Line 12 uses a range expression, which is inclusive, to pick up values from and including 16 through to and including 30. Line 16 then picks up all remaining ages. The <code>ageRange</code> variable in <code>newPerson</code> is set accordingly. Finally, on line 19, you return the newPerson object.</p>"},{"location":"tutorials/2-filterCollection.html#personaltcollection","title":"PersonAltCollection","text":"<p>You could just use a normal Collection class, extracting the instance of <code>PersonAlt</code> using <code>getNthElementRaw()</code>. But to show full functionality, you will create a custom Collection class:</p> <pre><code>Class PersonAltCollection as Collection\n\n    Sub New(), Collection(\"PERSONALT\", Nothing, False, False)\n        ' Nothing to do\n    End Sub\n\n    Function getNthElement(index as Long) as PersonAlt\n        Return getNthElementRaw(index)\n    End Function\n\nEnd Class\n</code></pre> <p>The constructor from line 3 is unusual. The incoming constructor takes no arguments, but the constructor of the base <code>Collection</code> class requires arguments. The correct syntax for this is <code>Sub</code> plus incoming constructor <code>New()</code>, then a comma and the base class name followed by the arguments to pass <code>, Collection(\"PERSONALT\", Nothing, False, False)</code>. The constructor doesn't need to do anything else, so there is no additional code.</p> <p>You then add a <code>getNthElement()</code> function from line 7, which will explicitly return an instance of the <code>PersonAlt</code> class. Because you're returning an object, you need the <code>Set</code> keyword, then you just need to return the value from the base class's <code>getNthElementRaw()</code> function.</p> <p>Note</p> <p>Because you're calling a different method in the base class, you can just use its name. There may be scenarios where you want to overload a method from the base class, such as <code>add()</code>, to run some code and then call the base class's <code>add()</code> function. This can be done using baseClassName..methodName, i.e. <code>Call Collection..add(source)</code></p>"},{"location":"tutorials/2-filterCollection.html#performing-the-transformation","title":"Performing the Transformation","text":"<p>Note</p> <p>The <code>transform</code> function also iterates the source Collection and adds elements to the new target Collection. If the target Collection is sorted, it will still use a Comparator to sort the incoming value against the values already in the target Collection.</p> <p>You perform the transformation like so:</p> <pre><code>Dim personAltTransformer as New PersonTransformer()\nDim personAltColl as New PersonAltCollection()\n\nCall sortedPersonColl.transform(personAltTransformer, personAltColl)\n</code></pre> <p>You create an instance of the <code>PersonTransformer</code> and an instance of the <code>PersonAltCollection</code> class. Then we pass these into the <code>transform</code> function of the resulting <code>sortedPersonColl</code> from the filter and sort. Because <code>addAll()</code> is a fluent function, we can perform the whole thing in a single line: <code>Call sortedPersonColl.addAll(personColl.filter(filter)).transform(personAltTransformer, personAltColl)</code>.</p>"},{"location":"tutorials/2-filterCollection.html#printing-out-the-result","title":"Printing out the Result","text":"<p>Finally, you can print out the result like so:</p> <pre><code>Dim i as Long\nDim altPerson as PersonAlt\nDo\n    Set altPerson = personAltColl.getNthElement(i)\n    Print altPerson.fullName &amp; \" - \" &amp; altPerson.ageRange\nLoop While ++i &lt; personAltColl.elementCount\n</code></pre> <p>After declaring variables you use <code>Do...Loop While</code> to iterate the Collection and print out the full name and age range.</p> <p>Note</p> <p>There are quite a few iterations of the initial Collection here. The code could be streamlined, if nothing more than the incoming Collection and outgoing printout were required. But the example shows using the broad variety of the Collection class functionality.</p> <p>Example Code</p>"},{"location":"tutorials/2-filterMap.html","title":"Filters, Transformers, Custom Comparators","text":""},{"location":"tutorials/2-filterMap.html#person-class","title":"Person Class","text":"<p>Imagine you have a class like so:</p> <pre><code>Class Person\n\n    Public key as String\n    Public firstName as String\n    Public lastName as String\n    Public age as Integer\n\nEnd Class\n</code></pre> <p>You can populate a map like so:</p> <pre><code>Dim personMap as New Map(\"PERSON\", Nothing, False)\nCall personMap.putPair(createPair(\"1\", \"Dennis\", \"Doe\", 84))\nCall personMap.putPair(createPair(\"2\", \"Denise\", \"Doe\", 82))\nCall personMap.putPair(createPair(\"3\", \"Andrew\", \"Doe\", 65))\nCall personMap.putPair(createPair(\"4\", \"Fred\", \"Doe\", 65))\nCall personMap.putPair(createPair(\"5\", \"Frances\", \"Doe\", 67))\nCall personMap.putPair(createPair(\"6\", \"John\", \"Doe\", 42))\nCall personMap.putPair(createPair(\"7\", \"Jane\", \"Doe\", 30))\nCall personMap.putPair(createPair(\"8\", \"Johnathan\", \"Doe\", 12))\nCall personMap.putPair(createPair(\"9\", \"Janet\", \"Doe\", 6))\nCall personMap.putPair(createPair(\"10\", \"Ken\", \"Doe\", 41))\nCall personMap.putPair(createPair(\"11\", \"Karen\", \"Doe\", 39))\nCall personMap.putPair(createPair(\"12\", \"Bill\", \"Doe\", 19))\nCall personMap.putPair(createPair(\"13\", \"Bob\", \"Doe\", 17))\nCall personMap.putPair(createPair(\"14\", \"Ben\", \"Doe\", 10))\n</code></pre> <p>On the first line, you create a Map that only accepts <code>Person</code> objects, but be un-sorted.</p> <p>Imagine the feed of data you have is from a database entered in a family tree format: Dennis and Denise had twins - William and Fred; William did not marry, but Fred married Frances and had two sons, John and Ken; John married Jane and had two children; Ken married Karen and had three children. Each person has an ID that's the primary key for the Person in the underlying database, in this case a sequential string.</p> <p>You add each Person object in turn to the Map, using the ID as the key. For brevity of code, you do this using a function:</p> <pre><code>Function createPair(id as String, firstName as String, lastName as String, age as Integer) as Pair\n\n    Dim person as new Person()\n    person.key = id\n    person.firstName = firstName\n    person.lastName = lastName\n    person.age = age\n    Set createPair = new Pair(id, person)\n\nEnd Function\n</code></pre>"},{"location":"tutorials/2-filterMap.html#filter-and-comparator","title":"Filter and Comparator","text":"<p>You now have a Collection of Person objects based on insertion order, which happens to be the order of the unique key. It may be that the code needs to perform some function with those or generate some reporting. Imagine at some point in the processing, you then want to filter out those Person entries with an age greater of 80 or more, and sort the rest on age, then first name.</p>"},{"location":"tutorials/2-filterMap.html#personfilter","title":"PersonFilter","text":"<p>To filter out entries you extend the MapFilter class, with a PersonFilter class. The MapFilter class has an empty constructor, so you don't need to specify the New method. But you do want to override the <code>filter()</code> method. In this case you want to return true only if the age is less than 80.</p> <pre><code>Class PersonFilter as MapFilter\n\n    Function filter(kvPair as Pair) as Boolean\n        Return CInt(kvPair.value.age) &lt; 80\n    End Function\n\nEnd Class\n</code></pre> <p>For the Collection, you created a Comparator to sort the Person objects. But the Comparator for a Map compares the keys, not the values. Each key must be a scalar value, and must also be unique. You're filtering out people at a maximum age threshold of 80, so you know the age will be a maximum of two digits. If you force the age to two digits, add a separator, then the full name, another separator, then the ID - this will give you a unique key to allow you to sort alphabetically on age, then name. For maximum efficiency, you can use the <code>MatchingDataTypeComparator</code>.</p>"},{"location":"tutorials/2-filterMap.html#passing-to-the-sorted-map","title":"Passing to the Sorted Map","text":"<p>Now you're ready to filter the Map and pass it to a sorted Map.</p> <p>Note</p> <p>Running a filter iterates the source Map and returns a new Map. Adding the resulting (filtered) Map to a new sorted Map also requires iterating the Map. For a small Map, the performance overhead will be minimal and there may be benefits for debugging in having multiple steps.</p> <pre><code>Dim filter as New PersonFilter()\nDim compar as New MatchingDataTypeComparator(false)\nDim tempMap as Map\nDim tempPerson as Person\nDim key as String\nDim i as Long\nDim sortedPersonMap as New Map(\"PERSON\", compar, True)\n\nSet tempMap = personMap.filter(filter)\nDo\n    Set tempPerson = tempMap.getNthValueRaw(i)\n    key = Format(tempPerson.age, \"00\") &amp; \",\" &amp; tempPerson.firstName &amp; \" \" &amp; tempPerson.lastName &amp; \",\" &amp; tempPerson.key\n    Call sortedPersonMap.putElement(key, tempPerson)\nLoop While ++i &lt; tempMap.elementCount\n</code></pre> <p>On line 1, you create an instance of the PersonFilter. On line 2, you create an instance of the MatchingDataTypeComparator, telling it to sort in ascending order. On line 7, you create a sorted Map passing in the MatchingDataTypeComparator for sorting and identifying uniques.</p> <p>On line 9, you perform the filter. But you need a different key. So you loop the filtered Map, extracting the relevant Person object in line 11. On line 12, you construct the key, ensuring age is fixed at two digits. Finally, you put the key and Person object into the new sorted Map.</p> <p>Note</p> <p>If we are changing the key as well as filtering, it would actually make more sense to filter out entries in the <code>Do...Loop While</code> block or use a MapTransformer.</p>"},{"location":"tutorials/2-filterMap.html#transformer","title":"Transformer","text":"<p>With the Collection, you needed many steps, because you wanted to sort on age but not display the age. But with a Map, you have a key and a separate value. So you can do everything together. As with the Collection, you need a new class to hold the modified contents of Person:</p> <pre><code>Class AltPerson\n\n    Public fullName as String\n    Public ageRange as String\n\nEnd Class\n</code></pre> <p>You also need a transformer:</p> <pre><code>Class PersonTransformer as MapTransformer\n\n    Function transform(kvPair as Pair) as Pair\n        Dim tempPerson as Person\n        Dim newPerson as New AltPerson\n        Dim newKey as String\n\n        Set tempPerson = kvPair.value\n        If (tempPerson.age &lt; 80) Then\n            newKey = Format(tempPerson.age, \"00\") &amp; \",\" &amp; tempPerson.firstName &amp; \" \" &amp; tempPerson.lastName &amp; \",\" &amp; tempPerson.key\n            newPerson.fullName = tempPerson.firstName &amp; \" \" &amp; tempPerson.lastName\n            newPerson.ageRange = getAgeRange(tempPerson.age)\n            Return new Pair(newKey, newPerson)\n        End If\n    End Function\n\n    Function getAgeRange(age as Integer) as String\n        Select Case age\n            Case Is &lt; 18:\n                Return \"Child\"\n            Case 16 To 30\n                Return \"Young Person\"\n            Case Is &gt; 60\n                Return \"Pensioner\"\n            Case Else\n                Return \"Adult\"\n        End Select\n    End Function\n\nEnd Class\n</code></pre> <p>From line 17, you have a function to convert the age to an age range, the same kind of code we had for the Collection. From line 3, you have the transform method.</p> <p>On line 8, you store the current Person object into a temporary variable. From line 9, you have an if block to only return something if the age is less than 80. On line, 10 you construct the new key, to sort on age, first name and last name - as you did for the sorted Map. On lines 11 and 12, you build the new AltPerson object. Finally on line 13, you return the new Pair of new key and AltPerson object. Because the function returns a Pair, which is an instance of a class, the default return value will be Nothing and this is used if age is 80 or higher.</p> <p>You can then process and print out the results using this code:</p> <pre><code>Dim transformedMap as New Map(\"ALTPERSON\", Nothing, False)\nDim transformer as New PersonTransformer()\nDim altPerson as AltPerson\n\nCall personMap.transform(transformer, transformedMap)\nDo\n    Set altPerson = transformedMap.getNthValueRaw(i)\n    Print altPerson.fullName &amp; \" - \" &amp; altPerson.ageRange\nLoop While ++i &lt; sortedPersonMap.elementCount\n</code></pre> <p>On the first line, you create a map to hold the transformed objects, then you create the PersonTransformer. On line 5, you perform the transformation. Then you iterate through the Map, printing out the details.</p> <p>Example Code</p>"}]}